# Copilot Instructions for ProBestoJarvisAI

- **Entrypoint & config**: Run the assistant from [jarvis/main.py](jarvis/main.py); it loads settings from [jarvis/config.json](jarvis/config.json) and wires `JarvisCore`. Use `python main.py` (or `python main.py --daemon` for background logging to `~/Desktop/JarvisData/logs`).
- **Preferred core**: Import the modern engine from the package, not the legacy module. Use `from system.core import JarvisCore` (which resolves to [jarvis/system/core/engine.py](jarvis/system/core/engine.py)); avoid relying on the legacy [jarvis/system/core.py](jarvis/system/core.py) unless intentionally patching old code. The namespace clash means explicit imports matter (tests use `from system.core.engine import JarvisCore`).
- **Runtime architecture**: JarvisCore composes EventBus + Scheduler (`core.lifecycle.runtime`), NLU (`brain/nlu/pipeline.py`), SkillDispatcher (`skills/actions/dispatcher.py`), logging (`skills/system/logging/manager.py`), storage/context (`brain/memory/*`), LLM manager, and an ActiveLearning engine. Voice IO goes through `jarvis_io` (AdvancedCLI, STT/TTS, VoiceIOPipeline). Responses are formatted in [jarvis/system/core/responses.py](jarvis/system/core/responses.py).
- **Event flow**: Input → NLU → events `EVENT_NLU_INTENT`, `EVENT_INPUT_TEXT/VOICE`, `EVENT_JARVIS_RESPONSE`. Handlers in [jarvis/system/core/handlers.py](jarvis/system/core/handlers.py) validate mode, dispatch skills, format responses, and emit `jarvis_response`. Short-term memory is maintained and logged every dispatch.
- **Skills contract**: Skills are classes with `run(entities, system_state_or_core)` returning a dict. Registration happens in `JarvisCore._register_skills()` inside [engine.py](jarvis/system/core/engine.py); update that mapping when adding skills. Dispatcher in [skills/actions/dispatcher.py](jarvis/skills/actions/dispatcher.py) instantiates classes unless you pass pre-built instances.
- **Operational modes & sessions**: ModeController and SessionManager (in `system.core`) gate which intents execute. Unknown intents respond with a skill list without dispatching. Ensure new skills respect mode restrictions when appropriate.
- **Voice & audio deps**: STT uses Vosk; TTS uses pyttsx3. `jarvis/check_voice_deps.py` can be used to verify audio dependencies. Voice can be toggled at runtime (`voz` command in CLI) or disabled via config (`tts`, `voice_enabled`).
- **CLI UX**: Advanced CLI lives in `jarvis_io/cli/interface.py`; runtime loop in [jarvis/system/core/runtime_manager.py](jarvis/system/core/runtime_manager.py) handles special commands (`ayuda`, `status`, `sesiones`, `modo ...`, `voz`, `analizar/propuestas/...`). Keep these in sync when changing commands or modes.
- **Data & logging**: JarvisLogger writes metrics and command logs; DataCollector tracks patterns and app usage when `data_collection` is true. Consent flags come from config; default tests set it false.
- **Testing quickstarts**: Use lightweight scripts in the repo root (`jarvis/test_boot.py`, `jarvis/test_cli.py`, `jarvis/test_integration.py`). They import the package engine and expect minimal config; run via `python test_boot.py` etc. No pytest setup is present.
- **Docs vs reality**: [jarvis/docs/architecture.md](jarvis/docs/architecture.md) describes an expanded layout (core/, jarvis_io/, learning), mostly aligned with the code under `jarvis/`. Some sections mention paths/files that are not present—trust the code over the doc when conflicting.
- **Hotspots for changes**: When modifying boot or event flow, touch [engine.py](jarvis/system/core/engine.py), [handlers.py](jarvis/system/core/handlers.py), and [runtime_manager.py](jarvis/system/core/runtime_manager.py) together. Adding skills also means updating responses in [responses.py](jarvis/system/core/responses.py) for custom phrasing.
- **Stateful behavior**: Jarvis keeps `command_history`, `short_term_memory`, and session info in memory; remember to trim lists (patterns run every 10 commands). Voice and scheduler components must be stopped via `core.stop()` to avoid hanging threads in tests.
- **External integrations**: LLMManager/providers and ActiveLearning hooks exist; many models/providers are stubs. When wiring new LLM features, ensure the manager is initialized before use and registered with skills that need it (see `research_and_contextualize`, `auto_programming`).
- **Conventions**: Spanish UI strings; responses default to Spanish. Keep emoji usage consistent with existing CLI/test scripts. Files stick to UTF-8 but prefer ASCII characters unless user-facing text.
- **Safe defaults for contributors**: Disable voice and data collection in test configs (`tts`: false, `data_collection`: false, `web_dashboard`: false). Use `workers` small (2) to keep EventBus light during development.

If anything is unclear or missing for your workflow, let me know what to expand or adjust.
